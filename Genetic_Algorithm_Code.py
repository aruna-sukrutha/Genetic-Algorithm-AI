#initialize population
import random
import math
import numpy

#fitness score calculation
def fitness():
    global best,fit_value,x_dec,y_dec,x,y
    x=[]
    y=[]
    #print("Population generated:\n",population)
    #to test if code is correctly working or not, uncomment below line and change to index 9 in iteration
    #population.append([1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1])
    for i in population:
        #dividing 16-bit chromosome to 8-bit x,y
        x.append(i[0:8])
        y.append(i[8:16])
    #print("partitioned x:\n",x)
    #print("partitioned y:\n",y)
    fit_value = []
    best=[]
    x_dec=[] #will have x's decimal value
    y_dec=[] #will have y's decimal value
    for i in x:
        i.reverse()
        x_value=0
        for j in range(8):
            x_value+=i[j]*math.pow(2,j) #converting x: binary to decimal value
        #print(x_value)
        x_value=(x_value*4/255)-2 #compressing x value in range (-2,2)
        x_dec.append(x_value)
    for i in y:
        i.reverse()
        y_value=0
        for j in range(8):
            y_value+=i[j]*math.pow(2,j) #converting y: binary to decimal value
        #print(y_value)
        y_value=(y_value*4/255)-2 #compressing y value in range (-2,2)
        y_dec.append(y_value)
    #print("corresponding x value:\n",x_dec,"\ncorresponding y-value:\n",y_dec)
    #fitness calculation function
    for i in range(8):
        #fitness function cal for (x,y)
        a = math.pow(1-x_dec[i],2)*math.exp(-math.pow(x_dec[i],2)-math.pow(y_dec[i]+1,2))
        b = (x_dec[i]-math.pow(x_dec[i],3)-math.pow(y_dec[i],3))*math.exp(-math.pow(x_dec[i],2)-math.pow(y_dec[i],2))
        fit_value.append(a-b)
        x[i].reverse()#normalising reversed string
        y[i].reverse()
        best.append([a-b,[x[i],y[i]]]) #store fitness value, (x,y)
    low = round(min(best)[0],3) #rollete wheel selection
    print("low:",low) #rollette wheel selection...to get rid of maximum -ve numbers
    if low<0:
        for i in best:
            #print("best",i[0])
            i[0]+=abs(low)
            #print("best",i[0])
    print("Fitness before rollete wheel selection:\n",fit_value)
    index_max=fit_value.index(max(fit_value))
    #print(best)
    best.sort()
    best.reverse()
    print("Chromosome maximum fitness value after rollete wheel selection: ",best[0][0]," and it's x,y values are: ",best[0][1][0],best[0][1][1])
    #print("Sorted values:\n",best)
    return best #fitness value and (x,y)

def selectparents():
    global parents
    parents = []
    c=0
    #print("selected parents",parents)
    for i in best:
        if c==2: #selecting best 2 parents (x,y)
            break
        else:
            parents.append(i[1][0]+i[1][1])
            #parents.append(i[1][1])
            c+=1
    #print("selected parents:",parents)
    return parents #returns 2 16-bit chromosome parents

def crossover() :
    global parents
    pc = 0.7 #cross over probability
    c = round(16*pc)
    cross_point = random.randint(0,c)
    print("cross point:",cross_point)
    parents = parents + list([(parents[0][0:cross_point] + parents[1][cross_point:16])])
    parents = parents + list([(parents[1][0:cross_point] + parents[0][cross_point:16])])
    #print("crossover:",parents)
    return parents[2:]#will return 2 offsprings after index 1`

def mutation():
    global populations, parents,offspring_crossover
    mute = random.randint(1,100) #probability of 1 is 1/100=0.01
    if mute == 1:
        x = random.randint(0,1) #since 2 indexes
        y = random.randint(0,15) #since length of parents chosen is 16
        offspring_crossover[x][y] = 1-offspring_crossover[x][y] #1 to 0; 0 to 1
    #print("mutation:",population)
    return offspring_crossover

global best_outputs
best_outputs = []
num_generations = 200
global population
global size
size = 8
global graph
graph = []
#generating 16-gene/bit chromosome with population size=8
population =([[random.randint(0,1) for x in range(16)] for i in range(size)])
print("Initial autogenerated population:\n",population)
for i in range(num_generations):
    print("Generation : ", i+1)

    # Measuring the fitness of each chromosome in the population.
    fit = fitness()
    print("Fitness:")
    print(fit) #will have best (fitness,(x,y)) for this generations in fit,best
    best_outputs.append(max(fit)) #will have best (fitness,(x,y)) for all generations in best_outputs
    graph.append(fit[0][0]) #max fitness value is used for graph representation

    # Selecting the best parents in the population for mating.
    parents = selectparents()
    print("Parents:")
    print(parents)

    # Generating next generation using crossover.
    offspring_crossover = crossover()
    print("Crossover:")
    print(offspring_crossover)

    # Adding some variations to the offspring using mutation.
    offspring_mutation = mutation()
    print("Mutation:")
    print(offspring_mutation)

    # Creating the new population based on the present population, parents and offspring.
    for i in range(0,6):
        population[i]=fit[i][1][0]+fit[i][1][1] #x+y concatenaing for top 6 in fit
    population[6]=offspring_mutation[0] #append mutated offspring1
    population[7]=offspring_mutation[1] #append mutated offspring2
    print("Next generation Population:")
    print(population)

# finding best fitness value of all 200 generation and it's corresponding (x,y)
best_outputs.sort()
best_outputs.reverse()
print("Best fit value to the function: ", best_outputs[0][0]," and its x,y values:",best_outputs[1][1])

# graph representation
import matplotlib.pyplot
matplotlib.pyplot.plot(graph)
matplotlib.pyplot.xlabel("Genration")
matplotlib.pyplot.ylabel(" Max fitness in each generation")
matplotlib.pyplot.show()
